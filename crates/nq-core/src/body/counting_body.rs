use std::{sync::Arc, task::Poll, time::Duration};

use hyper::body::{Body, Bytes};
use tokio::sync::mpsc;
use tracing::{debug, error, trace};

use crate::{Time, Timestamp};

/// [`BodyEvent`]s are generated by a [`CountingBody`] and describe the number
/// of total bytes seen or that the body has finished.
#[derive(Debug)]
pub enum BodyEvent {
    /// The number of bytes sent by the wrapped body at the given [`Timestamp`].
    ByteCount {
        /// When the event was generated.
        at: Timestamp,
        /// The total number of bytes seen.
        total: usize,
    },
    /// The [`CountingBody`] has finished sending the body it wraps.
    Finished {
        /// When the body finished.
        at: Timestamp,
    },
}

pin_project_lite::pin_project! {
    #[allow(missing_docs)]
    pub struct CountingBody<B> {
        #[pin]
        inner: B,
        time: Arc<dyn Time>,
        last_sent: Timestamp,
        update_every: Duration,
        poll_count: u8,
        total: usize,
        events_tx: Option<mpsc::Sender<BodyEvent>>,
    }
}

impl<B> CountingBody<B> {
    /// Create a [`CountingBody`] by wrapping the given body. Updates are sent
    /// every `update_every` duration and timestamps are taken with the given
    /// [`Arc<dyn Time>`].
    pub fn new(inner: B, update_every: Duration, time: Arc<dyn Time>) -> Self {
        let last_sent = time.now();

        Self {
            inner,
            time,
            last_sent,
            update_every,
            poll_count: 0,
            total: 0,
            events_tx: None,
        }
    }

    /// Subscribe to [`BodyEvent`] updates from the [`CountingBody`]. This
    /// removes any previous subscribers.
    pub fn subscribe(&mut self) -> mpsc::Receiver<BodyEvent> {
        let (events_tx, events_rx) = mpsc::channel(1024);
        self.events_tx = Some(events_tx);
        events_rx
    }

    /// Set the sender that [`BodyEvent`]s are sent on.
    pub fn set_sender(&mut self, events_tx: mpsc::Sender<BodyEvent>) {
        self.events_tx = Some(events_tx);
    }
}

impl<B> Body for CountingBody<B>
where
    B: Body<Data = Bytes>,
    B::Error: std::fmt::Debug,
{
    type Data = B::Data;

    type Error = B::Error;

    #[inline(always)]
    fn poll_frame(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> Poll<Option<Result<hyper::body::Frame<Self::Data>, Self::Error>>> {
        let this = self.project();

        trace!("polling frame");
        match this.inner.poll_frame(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                if let Some(data) = frame.data_ref() {
                    *this.total += data.len();
                }

                // Only check elapsed time every 5 frames
                if *this.poll_count >= 5 {
                    let now = this.time.now();

                    // We've waited long enough, send an update.
                    if now.duration_since(*this.last_sent) >= *this.update_every {
                        // We can drop the error here since this is an
                        // increasing counter. The next send will hopefully
                        // capture it.
                        if let Some(tx) = this.events_tx {
                            let event = BodyEvent::ByteCount {
                                at: now,
                                total: *this.total,
                            };

                            debug!(?event, "sending event");
                            let _ = tx.try_send(BodyEvent::ByteCount {
                                at: now,
                                total: *this.total,
                            });
                        }
                    }

                    *this.poll_count = 0;
                } else {
                    *this.poll_count += 1;
                }

                Poll::Ready(Some(Ok(frame)))
            }
            // Stream finished, send the last count
            Poll::Ready(None) => {
                let now = this.time.now();

                debug!("body finished");
                if let Some(tx) = this.events_tx {
                    let event = BodyEvent::ByteCount {
                        at: now,
                        total: *this.total,
                    };

                    debug!(?event, "sending event");
                    let _ = tx.try_send(BodyEvent::ByteCount {
                        at: now,
                        total: *this.total,
                    });

                    debug!(at=?now, "sending finished");
                    let _ = tx.try_send(BodyEvent::Finished { at: now });
                }

                Poll::Ready(None)
            }
            Poll::Ready(Some(Err(e))) => {
                error!(error=?e, "body errored");
                Poll::Ready(Some(Err(e)))
            }
            Poll::Pending => {
                trace!("body pending");
                Poll::Pending
            }
        }
    }
}
